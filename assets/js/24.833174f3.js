(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{607:function(t,e,s){"use strict";s.r(e);var n=s(15),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("参考资料：")]),s("p",[s("a",{attrs:{href:"https://www.zhihu.com/question/36132386",target:"_blank",rel:"noopener noreferrer"}},[t._v("二分查找有几种写法？它们的区别是什么？"),s("OutboundLink")],1)])]),s("h2",{attrs:{id:"何为二分查找"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#何为二分查找"}},[t._v("#")]),t._v(" 何为二分查找")]),t._v(" "),s("ol",[s("li",[t._v("将搜索区间以中位值为界，划分成两个区间。")]),t._v(" "),s("li",[t._v("然后将中位值与目标值做比较，如果中位值比目标值大，即目标值处于左区间，缩小右边界至中位值；若中位值比目标值小，即目标处于右区间，缩小左边界至中位值。")]),t._v(" "),s("li",[t._v("以新的左右边界为搜索区间，重新计算中位值，重复以上步骤，直至左右区间重叠。即左区间等于右区间")])]),t._v(" "),s("h2",{attrs:{id:"流程图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流程图"}},[t._v("#")]),t._v(" 流程图")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('flowchart TB\nS[开始]--\x3eI[输入数组和目标值]\nI --\x3e C["first=0,last=length,mid=Math.floor(first+(last-first)/2)"] \nC --\x3e D{左右边界是否重叠}\nD--\x3e|是|E{左边界firts是否等于目标值} \nE--\x3e|是|返回first值 --\x3e 结束\nE--\x3e|否|目标值不在数组内 --\x3e 结束\nD--\x3e|否|D2{"目标值 < mid"}\nD2--\x3e|是|F["last = mid"]--\x3eD\nD2--\x3e|否|G["first = m + 1"]--\x3eD\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[s("img",{attrs:{src:"/img/flowchartbybinarysearch.png",alt:"output"}})]),t._v(" "),s("h2",{attrs:{id:"各步骤注意点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#各步骤注意点"}},[t._v("#")]),t._v(" 各步骤注意点")]),t._v(" "),s("ol",[s("li",[t._v("明确左右界限和中间值\nfirst为0，last为length（因为区间为左闭右开，即实际搜索范围为lenght-1）\n中间值为first + （last-first）/2")]),t._v(" "),s("li",[t._v("在左右区间不重叠的循环条件内将目标值与中位值作比较\n左右区间不重叠，说明搜索范围仍未覆盖全数组。")]),t._v(" "),s("li",[t._v("根据比较结果缩小边界范围")])]),t._v(" "),s("ul",[s("li",[t._v("目标值等于中间值：查找结束，返回中间值下标")]),t._v(" "),s("li",[t._v("目标值小于中间值：mid 变为新的right边界（右开，mid值未检查，即不在搜索区间）")]),t._v(" "),s("li",[t._v("目标值大于中间值：mid+1 变为新的left边界（因为左闭，mid值已经检查过）")])]),t._v(" "),s("h2",{attrs:{id:"相关题目"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#相关题目"}},[t._v("#")]),t._v(" 相关题目")]),t._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/binary-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("704"),s("OutboundLink")],1),t._v("\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。")])]),t._v(" "),s("ul",[s("li",[t._v("解题思路：一道非常标准的二分搜索，目标值存在时，返回first，目标值不存在时，返回-1（因为区间设置左闭右开，最后一步的比较落在左边界，所以返回first）")]),t._v(" "),s("li",[t._v("时间复杂度： O(log n)，其中 n 是数组的长度。")])]),t._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/first-bad-version/",target:"_blank",rel:"noopener noreferrer"}},[t._v("278"),s("OutboundLink")],1),t._v("\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。")])]),t._v(" "),s("ul",[s("li",[s("blockquote",[s("p",[t._v("leetcode评论区解题思路：\n具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。\n这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧O(logn) 次。")])])]),t._v(" "),s("li",[s("p",[t._v("解题思路：这道题没有直接给出一个可以作比较的target值，而是需要调用isBadVersion(version)函数，通过返回值来判断是否要继续循环。")])]),t._v(" "),s("li",[s("p",[t._v("时间复杂度： O(log n)，其中 n 是其中 n 是给定版本的数量。")])]),t._v(" "),s("li",[s("p",[t._v("空间复杂度：O(1)。我们只需要常数的空间保存若干变量")])])]),t._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/search-insert-position",target:"_blank",rel:"noopener noreferrer"}},[t._v("35"),s("OutboundLink")],1),t._v("\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。")])]),t._v(" "),s("ul",[s("li",[t._v("解题思路：704的变型，需要考虑目标值不存在于数组中时的情况")]),t._v(" "),s("li",[t._v("时间复杂度：O(log n)， n 为数组的长度。二分查找所需的时间复杂度为 O(logn)。")]),t._v(" "),s("li",[t._v("空间复杂度：O(1)。我们只需要常数的空间保存若干变量")])])])}),[],!1,null,null,null);e.default=r.exports}}]);